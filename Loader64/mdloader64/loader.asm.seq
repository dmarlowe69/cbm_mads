;*********************************; ZEROPAGE USAGE EQUATES;*********************************STATUS=$90    ;STATUS BYTEZEROPG=$FB    ;ZERO PAGE POINTER;*********************************; RETURN TO BASIC EQUATE;*********************************INIT  =$E391  ;BASIC WARM START;*********************************; KERNAL JMUP TABLE EQUATES;*********************************STOP  =$FFE1  ;CHECK FOR STOPSETLFS=$FFBA  ;SET LOGICAL FILESETNAM=$FFBD  ;SET FILENAMEOPEN  =$FFC0  ;OPEN FILECLOSE =$FFC3  ;CLOSE LOGICAL FILECHKIN =$FFC6  ;OPEN INPUT CHANNELCLRCHN=$FFCC  ;RESET I/O CHANNELSCHRIN =$FFCF  ;GET KEYBOARD INPUTCHROUT=$FFD2  ;OUTPUT CHARACTER;*********************************;; LOADER64 ENTRY POINT;;*********************************LOADER JSR CLRCHN  ;RSET I/O LDA #$00        ;ZERO BYTE STA RECORD      ;RECORD COUNT STA RECORD+1    ; STA OFFSET      ;LOAD OFFSET STA OFFSET+1    ; STA STATUS      ;I/O STATUS;*********************************; PRINT TITLE;********************************* LDX #MSG7-MSG1  ;OFFSET FOR TITLE JSR PRINT       ;PRINT TITLE JSR GETOFF      ;GET LOAD OFFSET BCC LOADER      ;IF ERROR RESET;*********************************; INPUT FILE NAME;********************************* LDX #MSG8-MSG1  ;FILE NAME JSR PRINT       ;PRINT IT LDX #$28        ;CHAR COUNT STX COUNT       ;STORE IN COUNTSPACE DEC COUNT  ;DEC COUNT BEQ LOADER      ;IF ZERO RESET JSR CHRIN       ;GET CHAR CMP #' '        ;IS IT A SPACE BEQ SPACE       ;IF SO LOOP CMP #$0D        ;IS FIRST CR? BNE NAME        ;IF NOT BRANCH JMP QUIT        ;QUIT LOADER;*********************************; INPUT AND PARSES FILENAME;*********************************NAME LDX #$00    ;ZERO BYTE STX COUNT1      ;CHAR COUNT BEQ CRLF        ;BRANCH ALWAYSGETC  JSR CHRIN  ;GET NEXT CHAR CMP #' '        ;IS IT A SPACE? BEQ DNAME       ;NONE ALLOWEDCRLF CMP #$0D    ;IS IT CR? BEQ DNAME       ;END OF NAME LDX COUNT1      ;GET CHAR COUNT CPX #$0F        ;15 CHARS? BEQ LOADER      ;RESTART LOADER STA BUF,X       ;STORE CHAR INX             ;INC OFFSET STX COUNT1      ;CHAR COUNT JMP GETC        ;GET NEXT CHAR;*********************************; ADD DISK SEQ FILENAME;*********************************DNAME LDA #',' ;ASCII "," STA BUF,X     ;PUT IN BUFFER INX           ;INC OFFSET LDA #'S'      ;FOR SEQ FILE STA BUF,X     ;PUT IN BUFFER INX           ;INC OFFSET STX COUNT1    ;SAVE NUMBER CHARS;*********************************; OUTPUT CARRAIGE RETURN;********************************* LDA #$0D      ;ASCII CR JSR CHROUT    ;PRINT IT;*********************************; COMMAND CHANNEL INITIALIZE DRIVE;********************************* LDA #$07    ;FILE #7 LDX #$08    ;DEVICE #8 LDY #$0F    ;SEC ADR #15 JSR SETLFS  ;SET FILE PARA; LDA #'I'    ;ASCII I STA USER    ;STORE IN BUF1 LDA #'0'    ;ASCII ZERO STA USER+1  ;STORE IN BUF1; LDX #<USER  ;LOW FILENAME LDY #>USER  ;HIGH FILENAME LDA #$02    ;LENGTH OF NAME JSR SETNAM  ;SET FILENAME JSR OPEN    ;OPEN FILE; LDA STATUS  ;GET STATUS BEQ OK      ;ZERO IF OK CMP #$40    ;IS IT 64? BNE ERROR1  ;ERROR;OK LDA #$07  ;FILE #7 JSR CLOSE   ;CLOSE FILE;*********************************; OPEN OBJECT FILE;********************************* LDA #$07    ;FILE #7 LDX #$08    ;DEVICE #8 LDY #$07    ;SECOND ADDRESS JSR SETLFS  ;SET FILE; LDX #<BUF   ;LOW FILENAME LDY #>BUF   ;HIGH FILENAME LDA COUNT1  ;GET LENGTH JSR SETNAM  ;SET FILENAME; JSR OPEN        ;OPEN FILE LDA STATUS      ;CHECK STATUS BEQ OK3         ;IF ZERO OK CMP #$40        ;END OF FILE? BEQ OK3         ;IF SO OKERROR1 JMP ERROR ;FILE ERROR;OK3 LDX #$07     ;FILE #7 JSR CHKIN       ;INPUT FILE;*********************************; CHECK STOP KEY FOR BREAK;*********************************CKSTOP JSR STOP  ;CHECK STOP BNE OK2         ;IF NOT GO ON. JMP BREAK       ;BREAK ERROR;*********************************; INPUT CODE IN CBM OBJECT FORMAT;*********************************OK2  JSR INPUT   ;GET BYTE CMP #';'        ;START OF RECORD BNE CKSTOP      ;IF NOT TRY AGAIN; LDA #$00        ;ZERO BYTE STA USER        ;ZERO CHECK LOW STA USER+1      ;ZERO CHECK HIGH STA COUNT       ;ZERO BYTE COUNT; JSR GETBYT      ;GET BYTE BNE RECGOD      ;<>0 NOT LAST JSR GETBYT      ;GET RECORD COUNT CMP RECORD+1    ;SAME AS REC HIGH BEQ NEXCT       ;IF EQUAL NEXT JMP RECERR      ;BAD REC COUNT;NEXCT JSR GETBYT ;GET RECORD COUNT CMP RECORD      ;SAME AS REC LOW BNE RECERR      ;BAD REC COUNT JMP QUIT        ;ALL LOADED;*********************************; INPUT RECORD;*********************************RECGOD STA NUMBYT ;STORE NUM BYTES INC RECORD       ;INC REC COUNT BNE SKPIN1       ;ZERO? INC RECORD+1     ;IF SO INC HIGHSKPIN1 JSR SUMBYT ;SUM BYTES; JSR GETBYT       ;GET HIH ADDRESS PHA              ;SAVE CLC              ;CLEAR CARRY ADC OFFSET+1     ;ADD OFFSET STA ZEROPG+1     ;STORE IN POINT PLA              ;PULL ADDRESS JSR SUMBYT       ;SUM BYTES; JSR GETBYT       ;GET LOW ADDRESS PHA              ;STORE CLC              ;CLEAR CARRY ADC OFFSET       ;ADD OFFSET STA ZEROPG       ;STORE IN POINT BCC SKPINC       ;IF C=0 SKIP INC ZEROPG+1     ;INC HIH ADDRESSSKPINC PLA        ;PULL ADDRRESS JSR SUMBYT       ;SUM BYTES; LDA RECORD       ;GET REC COUNT CMP #$01         ;FIRST ONE BNE MORBYT       ;IF NOT GO ON; LDA #$0D         ;ASCII CR JSR CHROUT       ;PRINT IT JSR PRTADD       ;PRINT ADDRESS;*********************************; READ IN ASCII BYTE DATA;*********************************MORBYT JSR GETBYT ;GET DATA BYTE LDY COUNT        ;GET BYTE COUNT STY COUNT1       ;SAVE COUNT INC COUNT        ;INC COUNT; STA (ZEROPG),Y   ;STORE DATA CMP (ZEROPG),Y   ;CHECK DATA BNE NONRAM       ;IF <> ERROR JSR SUMBYT       ;SUM BYTES; DEC NUMBYT       ;DEC BYTE COUNT BNE MORBYT       ;IF <>0 MORE;*********************************; CHECK RECORD CHECKSUM;********************************* JSR GETBYT       ;GET HIH CHECK CMP USER+1       ;COMPARE, SAME? BNE CHKERR       ;IF NOT ERROR JSR GETBYT       ;GET LOW CHECK CMP USER         ;COMPARE, SAME? BNE CHKERR       ;IF NOT ERROR LDA #'.'         ;ASCII PERIOD JSR CHROUT       ;PRINT IT JMP CKSTOP       ;NEXT RECORD;*********************************; ERROR MESSAGE POINTERS;*********************************ERROR LDX #MSG6-MSG1  ;FILE ERROR;.BYTE $2CNONRAM LDX #MSG4-MSG1 ;NON-RAM LOAD;.BYTE $2CCHKERR LDX #MSG5-MSG1 ;CHECKSUM ERROR;.BYTE $2CBREAK LDX #MSG2-MSG1 ;BREAK ERROR;.BYTE $2CRECERR LDX #$00 ;BAD RECORD COUNT;*********************************; CLOSE OUT FILE AND RESET I/O;********************************* JSR PRINT      ;PRINT MESSAGEQUIT JSR CLRCHN ;RESET I/O LDA #$07       ;FILE #7 JSR CLOSE      ;CLOSE;*********************************; PRINT END OF LOAD ADDRESS;********************************* CLC            ;CLEAR CARRY LDA COUNT1     ;GET LAST OFFSET ADC ZEROPG     ;ADD TO LAST REC STA ZEROPG     ;LOAD ADDRESS LDA ZEROPG+1   ; ADC #$00       ; STA ZEROPG+1   ;; LDA #$0D       ;ASCII CR JSR CHROUT     ;PRINT IT; JSR PRTADD     ;PRINT ADDRESS LDX #MSG3-MSG1 ;END OF LOAD JSR PRINT      ;PRINT IT; JMP INIT       ;BACK TO BASIC;*********************************; OUTPUT STRING ROUTINE;*********************************PRINT STX COUNT ;PUT X IN COUNTPLOOP LDX COUNT ;LOAD X FROM COUNT LDA MSG1,X     ;LOAD CHAR PHP            ;SAVE STATUS FLAG AND #$7F       ;MASK BIT 8 JSR CHROUT     ;PRINT CHAR INC COUNT      ;INC OFFSET PLP            ;GET STATUS FLAG BPL PLOOP      ;IF BIT 8 ZERO RTS            ;RETURN;*********************************; CONVERT ASCII TO BYTE DATA;*********************************BYTASC CMP #$3A ;IS CHAR >9 PHP            ;PUSH P AND #$0F       ;MASK HIGH BYTE PLP            ;PULL P BCC EXIT1      ;IF <=9 OK ADC #$08       ;ADD OFFSETEXIT1 RTS       ;RETURN;*********************************; INPUT CHARACTER FORM DISK;*********************************INPUT JSR CHRIN ;INPUT CHAR PHA            ;STORE LDA STATUS     ;GET STATUS BYTE BEQ JUMP       ;IF ZERO OK CMP #$40       ;END OF FILE? BNE DISKER     ;IF NOT ERRORJUMP PLA        ;GET CHAR RTS            ;RETURN;*********************************; PULL RETURN RETURN FOR ERROR;*********************************DISKER PLA      ;PULL INPUT CHAR PLA            ;PULL RETURN PLA            ; PLA            ;PULL RETURN PLA            ; JMP ERROR      ;GOTO ERROR HANDLE;*********************************; SUM BYTES FOR CHECKSUMS;*********************************SUMBYT CLC      ;CLEAR CARRY ADC USER       ;ADD BYTE OF CHECK STA USER       ;REPLACE BYTE BCC EXIT       ;IF NO CARRY OK INC USER+1     ;INC HIGH BYTEEXIT RTS        ;RETURN;*********************************; GET OFFSET ADDRESS;*********************************GETOFF JSR INPUT ;GET CHAR CMP #$0D        ;IS IT CR? BEQ OFFOK       ;IF SO NO OFFSET CMP #' '        ;IS IT SPACE? BEQ OFFERR      ;IF SO ERROR JSR CHCKSP      ;NEXT CHAR BCC OFFERR      ;MORE SPACES? STA OFFSET+1    ;STORE HIH OFFSET JSR GETBYT      ;GET NEXT INPUT BCC OFFERR      ;ERROR? STA OFFSET      ;STORE LOW OFFSETOFFOK SEC        ;SET CARRY OK RTS             ;RETURNOFFERR CLC       ;CLEAR CARRY ERR RTS             ;RETURN;*********************************; INPUT CHARACTER INTO BYTE;*********************************GETBYT LDA #$00  ;ZERO BYTE STA TEMP        ;STORE IN TEMP JSR INPUT       ;GET CHAR INPUTCHCKSP CMP #' '  ;IS IT A SPACE? BNE CREBYT      ;IF NOT CREATE JSR INPUT       ;GET CHAR INPUT CMP #' '        ;IS IT S SPACE? BNE NEXBYT      ;IF NOT GO ON CLC             ;FLAG ERROR RTS             ;RETURN;*********************************; CREATE BYTE FORM 2 ASCII CHARS;*********************************CREBYT JSR BYTASC ;GET HIGH NIBBLE ASL A            ;LEFT JUSTIFY ASL A            ; ASCII CHAR ASL A            ;  IN HIGH ASL A            ;   NIBBLE STA TEMP         ;STORE JSR INPUT        ;GET INPUTNEXBYT JSR BYTASC ;CREATE LOW NIB ORA TEMP         ;PUT IN PLACE SEC              ;FLAG OK RTS              ;RETURN;*********************************; PRINT LOAD ADDRESS;*********************************PRTADD LDA ZEROPG ;LOW ADDRESS PHA          ;STACK IT LDA ZEROPG+1 ;GET HIGH BYTE JSR RIGHT    ;PRINT IT PLA          ;PULL LOW BYTE;RIGHT PHA     ;STACK BYTE LSR A        ;RIGHT JUSTIFY LSR A        ; BYTE IN LOW LSR A        ;  NIBBLE LSR A        ; JSR CHGASC   ;CONVERT BYTE TAX          ;STORE IN X PLA          ;PULL BYTE AND #$0F     ;MASK HIGH JSR CHGASC   ;CONVERT BYTE PHA          ;STACK RESULT TXA          ;GET HIGH NIBBLE JSR CHROUT   ;PRINT IT PLA          ;GET LOW NIBBLE JMP CHROUT   ;PRINT AND RETURN;*********************************; CONVERT BYTE TO ASCII CHAR;*********************************CHGASC CLC      ;CLEAR CARRY ADC #$F6       ;ADD OFFSET BCC NOSIX      ;IF C=0 OK ADC #$06       ;ADD OFFSSETNOSIX ADC #$3A  ;ADD OFFSET RTS            ;RETURN;*********************************; STORAGE;*********************************USER .WORD $AAAA   ;CHECKSUM VALUEOFFSET .WORD $AAAA ;LOAD OFFSETNUMBYT .BYTE $AA   ;NUMBER BYTESRECORD .WORD $AAAA ;RECORD NUMBERCOUNT .BYTE $AA    ;COUNTERTEMP .BYTE $AA     ;TEMPOARY;*********************************; FILENAME NAME BUFFER;*********************************BUF .BYTE $AA,$AA,$AA,$AA,$AA,$AA.BYTE $AA,$AA,$AA,$AA,$AA,$AA.BYTE $AA,$AA,$AA,$AA,$AA,$AA;*********************************COUNT1 .BYTE $AA   ;COUNTER;*********************************; ERROR MESSAGES;*********************************MSG1 .BYTE $0D.BYTE 'BAD RECORD COUN',$D4MSG2 .BYTE $0D.BYTE 'BREAK',$8DMSG3 .BYTE $0D.BYTE 'END OF LOA',$C4MSG4 .BYTE $0D.BYTE 'NON-RAM LOA',$C4MSG5 .BYTE $0D.BYTE 'CHECKSUM ERRO',$D2MSG6 .BYTE $0D.BYTE 'FILE ERRO',$D2;*********************************; MESSAGES;*********************************MSG7 .BYTE $0D,$0D,$0D;.BYTE 'LOLOAD.C64 V072882'.BYTE TITLE1,TITLE2.BYTE 'LOAD.C64 V072882'.BYTE $0D.BYTE '(C) 1982 BY COMMODORE BUSINESS '.BYTE 'MACHINES',$0D,$0D,$0D.BYTE 'HEX OFFSET (CR IF NONE) '.BYTE '?',$A0MSG8 .BYTE $0D.BYTE 'OBJECT FILE NAME ?',$A0;*********************************.BYTE $AA,$AA,$AA,$AA,$AA,$AA;*********************************.END